<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenCV Video Stream with Square Overlays</title>
    <script async src="https://docs.opencv.org/4.x/opencv.js" type="text/javascript"></script>
</head>
<body>
    <video id="videoInput" width="640" height="480" autoplay></video>
    <canvas id="canvasOutput" width="640" height="480"></canvas> <!-- For input stream with squares -->
    <canvas id="canvasMask" width="640" height="480"></canvas> <!-- For background mask -->

    <script>
        // Request camera access
        navigator.mediaDevices.getUserMedia({ video: true })
            .then((stream) => {
                let video = document.getElementById('videoInput');
                video.srcObject = stream;
                video.play();

                // Wait until video metadata is loaded (dimensions ready)
                video.addEventListener('loadedmetadata', onVideoLoaded, false);
            })
            .catch((err) => {
                console.error("Error accessing camera: " + err);
            });

        // OpenCV initialization
        cv['onRuntimeInitialized'] = () => {
            console.log("OpenCV.js is ready.");
        };

        function onVideoLoaded() {
            let video = document.getElementById('videoInput');
            let canvasOutput = document.getElementById('canvasOutput');
            let canvasMask = document.getElementById('canvasMask');
            let cap = new cv.VideoCapture(video);

            // Initialize Mats for frame and mask
            let frame = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC4);
            let fgmask = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC1);
            let fgbg = new cv.BackgroundSubtractorMOG2(500, 16, false);

            const FPS = 30;
            function processVideo() {
                try {
                    // Capture frame from video stream
                    cap.read(frame);

                    // Draw two outer red squares on the input frame
                    let squareSize = 50; // Size of the square
                    let spaceBetween = 5; // Space between squares (width)
                    let spaceBetweenStacks = 50; // Space between the two stacks

                    // Calculate the total width occupied by the two stacks
                    let totalWidth = (2 * squareSize) + spaceBetweenStacks + spaceBetween;

                    // Center the squares in the frame
                    let startX = frame.cols / 2; 
                    let bottomY = frame.rows - squareSize; // Position squares at the bottom

                    // Draw the bottom blue squares
                    offsetX = squareSize;
                    topLeftValueX1 = startX + offsetX; //left corner blue right square
                    topLeftValueX2 = startX - 2*offsetX; //left corner blue left square

                    bottomRightValueX1 = startX + 2*offsetX; //right corner blue right square
                    bottomRightValueX2 = startX - offsetX; //right corner blue left square

                    bottomRight = new cv.Point(bottomRightValueX1, bottomY); //set bottom right coordinate for right square
                    topLeft = new cv.Point(topLeftValueX1, bottomY + squareSize); //set top left coordinate for right square
                    cv.rectangle(frame, topLeft, bottomRight, [0, 0, 255, 255], 2); //draw right square

                    bottomRight = new cv.Point(bottomRightValueX2, bottomY); //set bottom right coordinate for left square
                    topLeft = new cv.Point(topLeftValueX2, bottomY + squareSize); //set top left coordinate for left square
                    cv.rectangle(frame, topLeft, bottomRight, [0, 0, 255, 255], 2); //draw left square


                    // Draw the top green squares (offset the left one to the left and the right one to the right)
                    topLeftValueX1 = startX + 1.5*offsetX;
                    topLeftValueX2 = startX - 2.5*offsetX;

                    bottomRightValueX1 = startX + 2.5*offsetX;
                    bottomRightValueX2 = startX - 1.5*offsetX;

                    bottomRight = new cv.Point(bottomRightValueX1, bottomY - 5);
                    topLeft = new cv.Point(topLeftValueX1, bottomY - squareSize - 5);
                    cv.rectangle(frame, topLeft, bottomRight, [0, 255, 0, 255], 2); // Draw in green

                    bottomRight = new cv.Point(bottomRightValueX2, bottomY - 5);
                    topLeft = new cv.Point(topLeftValueX2, bottomY - squareSize - 5);
                    cv.rectangle(frame, topLeft, bottomRight, [0, 255, 0, 255], 2);

                    // Apply background subtraction
                    fgbg.apply(frame, fgmask);

                    // Display the modified frame with squares on the first canvas
                    cv.imshow(canvasOutput, frame);
                    // Display the foreground mask on the second canvas
                    cv.imshow(canvasMask, fgmask);

                    // Schedule the next frame processing
                    setTimeout(processVideo, 1000 / FPS);
                } catch (err) {
                    console.error(err);
                }
            }

            // Start processing
            processVideo();
        }
    </script>
</body>
</html>
